; Matthew Dickerson & Thomas Dickerson
; ADDITIONAL CREDIT: Some of the code for translating from long-lat coordinates to distances and NetLogo coordinates was written by Karly Wentz in Summer 2011.
;
; Part of the Killer Whale IBM package.
; This file contains the procedures and reporters for interfacing with the 2D world. This includes:
;    Code for loading in an environment map, including the global constants related to the world and the patches-own variables.
;    Code for the underlying geometric & geographic data structures (described below).
;    Code for finding paths around the world, computing distances, and translating from long-lat to NetLogo coordinates.
; Distances read from prey files and prey data structures are converted to NetLogo native patch-unit distances.
;
; There are several underying data geometric & geographic structures used for interaction with the world, such as navigation.
;
; A Voronoi diagram of the islands is constructed. Essentially, each water patch belongs to the Voronoi region of the nearest island.
; Each island has a unique region number.  Every patch (land and water) knows its region.
; Each water patch stores a reference to the nearest land patch, and (if it is not adjacent to the patch) the positive distance to that patch in patch units 
; Patches on the boundaries between regions are labeled as Voronoi edges and Voronoi vertices.
; 
; Hunting regions are based on the Voronoi vertices of the islands. 
; Essentially, hunting regions are duals of the island Voronoi diagrams -- island Voronoi vertices become sites (centers) of hunting regions.
; THat is, each hunting region it is a Voronoi diagram whose sites are the island Voronoi vertices.  Each hunting region consists of all patches
; closer to the same Voronoi vertex than to any other.
; 
; There is also an underlanding graph structure made of nodes and links, used for computing efficient long distance travel paths for whales.
; Nodes are created on a small number of water patches. Some nodes -- usually associated with Voronoi vertices -- are special "anchor" nodes.
; Every node stores the information needed to find the most efficient path to every anchor node.  This makes it efficient to find a path 
; between any two nodes by having both patches find an efficient path to some anchor nodes.  (If every node where an anchor node, then paths would 
; be all be optimal, but the data storage requirements would be much greater.)  Since most paths will end up going through anchor nodes, they 
; are important parts of the whale travel algorithms.
; 

breed [nodes node]

nodes-own [
  anchor?                   ; TRUE if this is a special anchor nodes
  id                        ; A unique id number for anchor nodes, used for indexing the next two lists.
  nearest-anchor            ; The id of the nearest anchor node
  nearest-anchor-dist       ; THe distance in patch units (along the graph) to the nearest anchor node
  nextlist                  ; A list. nextnode [i] holds the next node on the shortest path from this node to the anchor with id i
  distlist                  ; A list. distlist [i] holds the distance from this node to the anchor with id i
]

globals [
  ; The following variables hold frequently used subsets of patches that meet certain conditions. 
  ; These globals save the program from repeateding filtering through all patches to find oft-used subsets
  water         ; will hold all water patches -- patches with (water? = true)
  coast         ; will hold all coastal patches -- the subset of water such that (coastal? = true)
  shore         ; land patches adjacent to water 
  vd-vertices   ; a list of all patches that are part of a Voronoi vertice -- that is patches that are adjacent to two (or more) different regions
  vd-edges      ; a list of all patches that are port of a Voronoi edge -- that is patches that are adjacent to exactly one different region

  max-shore-dist
  min-shore-dist  
  
  ; GLOBALS SET ACCORDING TO THE IMPORTED MAP (MAP-IMAGE) -- will change depending on the image
  km-width      ; width of the imported world in km
  km-height     ; height of the imported world in km
  kmpp          ; kms per patch -- width and height of a single patch in km
  

  ; ** THE FOLLOWING NEED TO BE SET BY THE PROCEDURE THAT INPUTS THE MAP ***
  ul-long-lat    ; Lists of length 2 that contain the long-lat coordinates of the four corners: ul=upper left, ur=upper right, etc.        
  ur-long-lat
  ll-long-lat 
  lr-long-lat 

  ocean-seed               ; a patch known to be in saltwater (water this is not a pond)
  land-seed                ; a patch known to be mainland -- or region 0
  
  ; Values representing the cut-offs between land, land/water mix (coastal) and open water. 
  ; Water-lower-threshold represents a threshold subtracted off of 10, and land-upper-threshold represents a threshold added onto 0.
  land-upper-threshold     
  water-lower-threshold   
]

patches-own [
  water?        ; true for all patches containing any ocean, this it includes coastal? patches.
  coastal?      ; true if this patch contains a mix of ocean and land; these are a subset of water? and are assumed navigable by whales
  visited?      ; used for various searches

  ; shore-dist is a measure of how far out to see a given water patch is -- a sort of distance to the nearest patch that is coast but adjacent to non-coast. 
  ; This is positive for non-costal water, 0 for water that is coast but adjacent to non-coast, and negative for coast that is more than 1 away from non-coast
  shore-dist     
  
  ;;  *** VD INFO ***
  region
  nearest-land
  vd-edge?
  vd-vertex?
  
  ;;  *** TRAVEL GRAPH INFO ***
  nearest-node  ; number of nearest node
  to-node       ; next patch on the path toward the nearest node, or self is nearest node on this patch
]

to SETUP-MONITOR [x y]
  if SETUP-MONITOR-LEVEL > x [show y]
end

; Information about the world is imported from two files.
; The first file is a text file that contains information such as the long-lat coordinates of the world, the dimension of the world, etc.
; The first line of the text file contains the name of a second file, an image file, that has the world map in grey-scale with black pixels
; for land and white pixels for water, and gray pixels for coast (land-water mix).
to load-map-parameters [map-file-name]
  file-open map-file-name
  
  let map-img-name file-read
  import-pcolors map-img-name
  
  let km-dims file-read
  
  set km-width item 0 km-dims
  set km-height item 1 km-dims
  set kmpp (km-width / world-width)
  
  set ul-long-lat file-read
  set ur-long-lat file-read
  set ll-long-lat file-read
  set lr-long-lat file-read
  
  let ocean-seed-ll file-read
  set ocean-seed convert-long-lat (item 0 ocean-seed-ll) (item 1 ocean-seed-ll)
  if (ocean-seed = nobody) [ DEBUG-MONITOR 1 "ERROR: ocean seed outside world" ]
  
  let land-seed-ll file-read
  set land-seed convert-long-lat (item 0 land-seed-ll) (item 1 land-seed-ll)
  if (land-seed = nobody) [ DEBUG-MONITOR 1 "ERROR: land seed outside world" ]
  
  set land-seed map [round ?] land-seed
  set ocean-seed map [round ?] ocean-seed
  
  set land-upper-threshold file-read
  set water-lower-threshold file-read
  
  ;SETUP-MONITOR 1 "Showing seed coordinates"
  ;show ocean-seed
  ;show land-seed
  
  file-close
end


to load-map
  SETUP-MONITOR 0 "Loading world map."
  

  load-map-parameters "se-map-data.txt"
  
  ; Find out which patches are water, and among those which are coastal, create a patchset of all the water patches, for later efficiency
  SETUP-MONITOR 1 "Identifying water patches..."
  extract-water-info
  set water patches with [water?]
  
  ; We can now create a patchset of all the coast and inland patches, for later efficiency
  ; Any patch bordering a land patch, even if it is 100% water, should also be considered coastal. Get a list of coastal waters.
  SETUP-MONITOR 1 "Identifying additional coastal patches..."
  ask water [
    ifelse any? neighbors with [not water?][
      set coastal? true 
      set pcolor white
    ][
      set coastal? false
    ]
  ]
  set coast water with [coastal?]
   
  SETUP-MONITOR 0 "Eliminating isolated water..."
  eliminate-ponds       ; Unmark patches that are water, but not connected to the ocean, so that sea creatures are not initialized there.
  ask water [set shore-dist 1]
  show-scale
  show-north
end

     
; Extract land-water information from map coloring.
; Set the boolean water? variable for each patch to be true or false, and for water patches, set the coastal? variable.
; Map should be gray-scale, with black=land and white=water and grey a max.  In NetLogo, black is pcolor 0.0, and white is pcolor 9.9
to extract-water-info
 ask patches [
    set vd-edge? false
    set vd-vertex? false
    
    ; Usually, 0.0 is black and 9.9 is white, but NetLogo sometimes gives x9.9 for white and x0 black where x is some other digit.  Fix this.
    if pcolor >= 10 [ ifelse (remainder pcolor 10 = 0) [set pcolor black][set pcolor white]]   
    ; All patches should now have a pcolor in the range 0..9.9, showing the percent of that patch that is water.
    
    ; Any patch with pcolor <= 2 is at least 80 % land; set it to land and color it light green
    ifelse (pcolor <= land-upper-threshold) [
      set pcolor green + 2           ;  Land patches (at most 20% water)
      set water? false
      set coastal? false
    ][                                ; All remaining patches have at least 20% water.
      set water? true                 ; Check to see if they are coastal (less than 100% water)
      ifelse pcolor < (white - water-lower-threshold) [
        set coastal? true
        set pcolor yellow
      ][
        set coastal? false
        set pcolor blue + 2.5
      ]
    ]
  ]
end

; Calculates the distance from each coast patch to the nearest non-coast water patch to be stored as a negative number in shore-dist. 
; (intuitively this gives a measure of how far up a narrow channel or narrow fjord that a patch is.)
; The value is stored as a negative number in shore-dist. Thus coast patches adjacent to non-coast will have shore-dist = 0, coast
; patches adjacent to these, but not adjence to a non-coast will have shore-dist = -1, etc.  
; Water patches that are non-coastal will have a positive shore-dist (set in another procedure)
to set-distance-in
  set min-shore-dist 0
  ask coast [set visited? false]                                         ; Keeps track of patches that have been completed, to avoid infinite loop
  let level coast with [any? neighbors with [water? and not coastal?]]   ; Coast adjacent to non-coast has shore-dist = 0, and is the starting level
  ask level [set visited? true set shore-dist 0]                         ; Initialize the base case -- coastal patches adjacent to non-coastal patches
  let templevel nobody                                                   ; templevel stores the next level to be visited
  let dist -1                                                            ; coast adjacent to shore-dist 0 but not adjacent to non-coast is shore-dist -1.
  while [level != nobody][
    ask level [
      ask neighbors with [coastal? and not visited?][                    ; If adjacent to an already visited coast, then this is reached at the next level
        set visited? true
        set templevel (patch-set templevel self) 
        set shore-dist dist
        set min-shore-dist min (list shore-dist min-shore-dist)
      ]
    ]
    set dist (dist - 1)  
    set level templevel
    set templevel nobody
  ]
end

; This procedure gets rid of all the water that is not connected to the ocean. 
; It starts with a patch that is known to be ocean, and then marks as visited? every patch that can be reached from this
; starting patch traveling only on water.  At the end, patches that were not visited are marked as not water? and are
; removed from the water, coast, and inland patch sets.
; Assumes that inland patches have already been found
to eliminate-ponds
  ask water [set visited? false]                            ; initial all water as unvisited
  let seed patch (item 0 ocean-seed) (item 1 ocean-seed)     ; pick a starting patch (seed) known not to be a pond (landlocked body of water)
  ask seed [set visited? true]                              ; the seed is now visited
  let to-process (list seed)                                ; to-process contains patches that have been visited, but from which neighbors have not been visited 
  while [length to-process > 0][                            ; from each visited patch in to-process, look for more unvisited water patches that are adjacent
     let next first to-process                              ; get the front-most patch from the to-process list
     set to-process but-first to-process 
     ; Make sure we don't slice through a thin section of island               
     ask [neighbors4] of next [                              ; visit any unvisited neighbors, and add those neighbors to the list to be processed
        if water? and not visited? [
           set visited? true
           set to-process lput self to-process
        ] 
     ]
  ]
  
  ; Any patch that was not visited, is landlocked water. Whales cannot travel there, so we remove it from our list.
  ask water with [not visited?][
    set pcolor green + 2
    set water? false
    set coastal? false
  ]
  ; remove the landlocked water patches from the global lists 
  set water water with [water?]
  set coast coast with [coastal?]
end

;==============================================


; This procedure reports water patches within distance d of the calling agent, where d is the distance traveled by stepping
; from one water patch to another. 
; The distance d is _not_ a straightline distance, but a distance along a water path. It is a combination of L1 and L-inf metrics, stepping
; horizontally, vertically, and diagonally, but never across land. It is thus an approximation of (and always at least as great as) the
; shortest distance a whale would actually travel to reach the given patch. Meaning that the number of patches returned will be smaller than
; the actual number reachable by whales traveling distance d.
to-report water-patches-within [d exclude-coast?]
  set visited? 0               
  let queue (list self)
  
  ;set pcolor red

  while [not empty? queue][
    let p first queue              ; Remove the next patch from the queue... 
    set queue but-first queue         ; ... and update the queue
    
    ; If some neighbors of p further away from the starting point than d, then neighbors need not be examined
    if (([visited?] of p) + 1 < d) [ 
      
      ask [neighbors4] of p [
        if water? and ((not coastal?) or (not exclude-coast?)) and (visited? < 0) [
         let best-neighbor min-one-of neighbors with [water? and ((not coastal?) or (not exclude-coast?)) and (visited? >= 0) and (segment-on-water? ([pxcor] of myself) ([pycor] of myself) pxcor pycor )] [visited? + (distance myself)]
         set visited? ([visited? + (distance myself)] of best-neighbor)
;         set pcolor red
         set queue lput self queue 
        ]
      ]
      
    ]
  ]
  let result water with [visited? >= 0]
  ;ask result [set visited? -1] ; don't keep this line in the finished code, it should be done externally, but keep it here for testing-sake to save doing it manually each time
  report result
end 

; Same as above, but returns the patches in an ordered list (ordered by distance) as (patch,distance) pairs.
to-report water-patches-within-to-list [d exclude-coast?]
  report sort-on [visited?] water-patches-within d exclude-coast?
end 

; Draw the map according to the seletion of the map-mode selector on the user interface
to redraw
  ask nodes [set hidden? true]
  ask links [set hidden? true]
  
  if map-mode = "shore distance" [color-by-shore-distance]
  if map-mode = "shore distance w/ graph" [
    color-by-shore-distance  
    ask nodes [set hidden? false]
    ask links [set hidden? false]  
  ]
  if map-mode = "prey density" [color-by-shore-distance]
  if map-mode = "voronoi" [color-voronoi-regions]
  if map-mode = "voronoi w/ graph" [
    color-voronoi-regions
    ask nodes [set hidden? false]
    ask links [set hidden? false]  
  ]
  if map-mode = "hunting regions" [color-hunting-regions]
  if map-mode = "hunting regions w/ graph" [
    color-hunting-regions    
    ask nodes [set hidden? false]
    ask links [set hidden? false] 
  ]
end

to color-by-shore-distance
  ask patches with [not water?][
    set pcolor green + 2
;    if ((pxcor mod region-width = 0) or (pycor mod region-width = 0)) [set pcolor black]
  ]
  ask coast [set pcolor white]
  let max-sd [shore-dist] of max-one-of water [shore-dist]
  ask water with [not coastal?][ 
    set pcolor scale-color blue shore-dist (max-sd * 1.2) (-.2 * max-sd) 
;    if ((pxcor mod region-width = 0) or (pycor mod region-width = 0)) [set pcolor black]
  ]
end

; ========================== MAP SCALE ======================================
; The north arrow and the distance scale are done with turtle pens so that they are not erased if the world is redrawn.
; The distance scale turtle dies once it is done. The north arrow turtle remains as the pointer of the arrow.

; Draw an arrow pointing north on the upper left part of the map
to show-north
  ; We just make a generic turtle on a land patch in the upper left, and have it travel due north dragging's its pen
  crt 1 [
    move-to (long-lat-patch -135.5 59.5)    ; A reasonable starting point in the upper left corner with room to travel north
    face (long-lat-patch -135.5 60)         ; A location due north -- i.e. with the same longitude and a high latitude
    pd set pen-size 2 set color red         ; Put the pend down for drawing and color it black
    fd 40 set size 15                       ; A 40 patch long line is nice and visible. Leave the agent there (with size 15) as a north arrow.
    set label-color black                   ; Add the word "north" as a lable for the arrow
    set label "North"  
  ]
end

; Create a km scale bar on the upper left part of the map
to show-scale
  ; We just make a generic turtle on a land patch in the upper left, and have it travel due north dragging's its pen
  crt 1 [
    set color black
    setxy (min-pxcor + 10) (max-pycor - 20)
    set heading 0
    pd 
    fd 10
    rt 90
    ; 5 10km ticks 
    repeat 5 [  fd (10 / kmpp)  rt 90  fd 5  back 5  lt 90 ]
    rt 90
    fd 10
    die
  ]
  
  ; Show the scale
  ask patch 95 608 [set plabel "50 km (10km/tick)" set plabel-color 0]
end 
    
;;====================================== VORONOI DIAGRAMS CONSTRUCTION ===============================

; The mainland as well as each island represent simple polygons. This procedure constructs the discretized Voronoi diagram of those polygons.
; First, each simple polygon land unit is identified and numbered, starting with the mainland as region 0. Each is colored randomly with (repeated) NetLogo colors.
; Next, each water patch is labeled with the region number of the nearest island.
to compute-vd
  SETUP-MONITOR 0 "Creating Voronoi diagram of water patches."
  SETUP-MONITOR 1 "Marking and labeling islands."
  ask patches [set region -1]                   ; initialization all patches to null region.
  
  ; Computing the discretized Voronoi diagram -- one Voronoi region for each island or land mass
  regionalize-land                              ; identify each distinct region (a simply polygonal land mass) and number all its patches
  label-water                                   ; find which region each water patch belongs to

  ; Identify which water patches are Voronoi edges and which are Voronoi vertices
  SETUP-MONITOR 1 "Identifying Voronoi features (edges)"
  find-edges
  SETUP-MONITOR 1 "Identifying Voronoi features (vertices)"
  find-vertices
  set max-shore-dist [shore-dist] of max-one-of water [shore-dist]
end

; Find all the distinct contiguous units of land, and label each with a unique region id, starting with the mainland as region 0.
to regionalize-land
  ; Get initial list of all land patches and initialize them as not belonging to any region.  Edge patches are ignored.
  SETUP-MONITOR 1 "Make list of land patches."
  let land-list patches with [not water?]; and count neighbors = 8]
  
  ; Number each region of land, starting with number 0 (the mainland)
  SETUP-MONITOR 1 "Dividing land into regions"
  let next-region 0   
  let seed patch (item 0 land-seed) (item 1 land-seed) ;(min-pxcor + 1) (max-pycor - 1)   ; Upper left corner is part of mainland, and should be part of region 0
  ask seed [
    set region next-region 
    set pcolor (region * 10 + 5)
  ]
  while [any? land-list][
    SETUP-MONITOR 2  ( word "Region: " next-region)
    let this-region (list seed)                    ; Create a queue of land patches to be added to this region
    while [length this-region > 0][
       let next first this-region                  ; Pull from the queue the next land patch to be added to this region
       set this-region but-first this-region 
       ask next [                                  ; Process the patch as follows...
         SETUP-MONITOR 3 ( word "Adding " self " to region" )
         ; land connects by neighbors, water connects by neighbors4
         ask neighbors with [region = -1 and not water?][; and count neighbors = 8][
           set region next-region 
           set pcolor (region * 10 + 5)
           set this-region lput self this-region
         ]
       ]
    ]
    
    ; Initialize for the next region.
    set next-region (next-region + 1)              ; Update region count
    set land-list land-list with [region = -1]     ; Remove from list all patches that were added to a region in the previous round -- keep only patches not yet in a region
    
    ; Pick a random seed for the next region
    if any? land-list [
      set seed one-of land-list
      ask seed [
        set region next-region 
        set pcolor (region * 10 + 5)
      ]
    ]
  ]  
end

; Compute the VD on all water patches. That is, label each such patch with the ID of the nearest land, and color it.
to label-water
  ; KEEP TRACK OF THE WORK BEING DONE FOR PROGRESS UPDATE
  SETUP-MONITOR 1 "Marking and labeling patches"
  
  ; Find all land patches adjacent to water. These will be used by water patches to (more efficiently) find the nearest shoreline, without measuring distance to all land.
  let shoreline patches with [(region >= 0) and (any? neighbors with [water? and shore-dist >= 0])]
  
  let label-queue []
  ask water [ set visited? false ]
  ask shoreline [ set label-queue lput self label-queue ]
  
  while [not empty? label-queue] [
   let p first label-queue
   set label-queue but-first label-queue
   ask [neighbors4] of p [
     if water? and not visited? [
       set label-queue lput self label-queue
       let best-neighbor nobody
       ifelse shore-dist <= 0 [
         set nearest-land p
         set best-neighbor p
       ][
         set best-neighbor min-one-of neighbors with [water? and visited?] [[distance myself] of nearest-land]
         set nearest-land [nearest-land] of best-neighbor
         set shore-dist distance nearest-land
       ]
       set region [region] of best-neighbor
       set pcolor region * 10 + 7.5
       set visited? true
       
     ]  
   ]  
  ]   
end


; Identify all water patches that are boundaries of a Voronoi region as vd-edge? patches. 
; Note that if two land-masses are separated by a single pixel, then one of them will not have an edge in-between.
to find-edges
  ask water [
    ifelse any? neighbors with [region != [region] of myself] [
      set vd-edge? true
    ][
      set vd-edge? false
    ]
  ]
  
  ; apparently agentsets are slow to update, so actually faster to do it all at the end
  set vd-edges water with [vd-edge?]
end

; Identify Voronoi vertices for each region -- these are patches adjoining at least two other regions.
; Vertices are subsets of edges.
to find-vertices
  ask water [
    set vd-vertex? false
    if vd-edge? [
      let found? false
      let nn neighbors with [water? and vd-edge? and (region != [region] of myself)]
      if any? nn [
        let v one-of nn
        if any? nn with [region != [region] of v ] [set found? true]
      ]
      if found? and not any? neighbors with [vd-vertex?] [
        set vd-vertex? true 
      ]
    ]
  ]
  
  ; apparently agentsets are slow to update, so actually faster to do it all at the end
  set vd-vertices water with [vd-vertex?]
end

;; === END OF VORONOI DIAGRAM SECTION ================

; ========================= PATH TESTING PROCEDURES ==================================
; Procedures to allow the user to test the path(s) a whale would follow to get from point A to point B
;
; Allow the user to click on a patch, and reports that patch. 
; To provide live feedback, the patch highlighted by the "watch" command during the selection process
; If the user selects a land patch, this will report a water patch instead.
to-report click-on-patch
  let wp one-of water
  let x [pxcor] of water
  let y [pycor] of water
  watch wp
  
  ; Busy wait loop so that the user presses and then releases the mouse
  while [not mouse-down?][]
  while [mouse-down?][
    set x mouse-xcor
    set y mouse-ycor
    if [water?] of patch x y [
      set wp patch x y
      watch wp
    ]
  ]
  reset-perspective
  report wp   
end

; Allow the user to click on two water patches, compute the path between them, and then color the path.
to test-a-path
  output-print "Select a starting patch."
  let start-path click-on-patch
  output-print "Select a destination."
  let end-path click-on-patch 
  color-path-list path-from-patch-to-patch start-path end-path
end

to-report click-on-point
  let x random-pxcor
  let y random-pycor
  watch patch x y

  ; Busy wait loop so that the user presses and then releases the mouse
  while [not mouse-down?][]
  while [mouse-down?][
    set x mouse-xcor
    set y mouse-ycor
    watch patch x y
  ]
  reset-perspective
  report (list x y)
end

to test-a-segment
  show "Select a starting point."
  let start-point click-on-point
  show "Select a destination point."
  let end-point click-on-point
  let path find-line (first start-point) (last start-point) (first end-point) (last end-point)
  ifelse path = nobody [
    show "Line segment cross land. No path reported."
  ][
    color-path-list path
  ]
end

to color-path-list [p-list]
  foreach p-list [ask ? [set pcolor red]]
end

;; ============================ GRAPH CONSTRUCTION ALGORITHMS ====================

; This creates a graph of nodes for node based travel. 
; Each water patch will know its nearest node and have a pointer to the next patch on a path to its nearest node. 
; Some nodes will be marked as special anchor nodes, and every node will also knows its nearest anchor and a path to that anchor.
; Dikstra's algorithm is used to computer, for every node, the shortest path to every anchor node.  (Space requirements to compute the path from every
; node to every other is too large.)  Using anchor nodes allows an approximation of the most efficient path between two nodes.
to make-graph
  make-nodes                       ; Create nodes densely enough so that efficent paths can be found to water patches via nodes
  make-edges                       ; Create edges to make a sparse graph. Edges should be between visible nodes -- that is a straight path only through water.
  remove-disconnected-nodes        ; Prune from the graph useless nodes that don't have paths or loops.
  remove-deadends
  find-nearest-nodes               ; For each water patch, find the nearest node.
end

; Create nodes (anchor and non-anchor) for the travel graph.
; Anchor nodes are created at Voronoi vertices
; Non anchor nodes are created on Voronoi edges
; Nodes are pruned based on density constraints, with nodes being less dense further from shore
; Assumes that all patches have been marked with shore-dist, which is >0 if not adjacent to shore, and <0 if not adjacent to any patches that are >0.
; Assumes that Voronoi vertices have been identified.
to make-nodes
  SETUP-MONITOR 0 "Creating graph nodes."

  ; Ignore British Columbia.  We will only deal with southeast alaska, where we have prey data
  ; *** FOR GENERALIZATION TO OTHER LOCATIONS... LATER THIS SHOULD BECOME A LIST OF IGNORED LAND MASSES STORED IN THE MAP DATA FILE ******
  let bc1 [region] of patch 1034 223
  let bc2 [region] of patch 1021 157
  
  ; constants
  let max-sd 50                   ; Put in no nodes further from shore than this
  let min-anchor-dist 35          ; Initially make sure that all nodes are farther apart than this
  let highest-y 500               ; Don't put nodes above this position as they are only fjords with no passages
  

  ; Uses Voronoi vertices as locations for anchor nodes, but don't place two within min-anchor-dist of each other

  ask vd-vertices [
    if not any? nodes in-radius min-anchor-dist [make-anchor-here]
  ]
  SETUP-MONITOR 1 (word (count nodes) " anchors were created.")
  
  ; Create non-anchor nodes on Voronoi edges.  
  ; All non-anchor nodes shoudl be within max-sd of the shore and not in fjords.  They should be less dense further from shore.
  let candidate-edges vd-edges with [(shore-dist <= max-sd) and (shore-dist > 0) and (pycor < highest-y) and (region != bc1) and (region != bc2)]
  ask n-of ((count candidate-edges) / 5) candidate-edges[
    if not any? nodes in-radius ((max (list 2 shore-dist)) ^ 1.05) [make-node-here]        ; Don't put two nodes too close to each other.
  ]
  
  SETUP-MONITOR 1  (word (count nodes with [not anchor?]) " non-anchor nodes were created.")

end

; Now add edges.  Anchors should be connected to all other anchors for which there is a straight-line path across water.
; Other nodes are sparsely connected.
to make-edges
  SETUP-MONITOR 0  "Creating graph edges"
  ; Link all visible anchors with a single link
  let anchors nodes with [anchor?]
  ask anchors[      
    ask other anchors [if (not link-neighbor? myself) and (segment-on-water? pxcor pycor [pxcor] of myself [pycor] of myself) 
       [create-link-with myself [set color red set hidden? true]]] 
  ]
  

  ; Create a sparse graph of edges among other nodes. Link each node to visible neighbors among the six closest neighbors.
  ask nodes [ 

    let closest-neighbors min-n-of 6 other nodes [distance myself]
    ask closest-neighbors [
      if (not link-neighbor? myself) and (segment-on-water? pxcor pycor [pxcor] of myself [pycor] of myself) 
          [create-link-with myself [set color white set hidden? true]]
    ]
  ]  
  SETUP-MONITOR 0  (word (count links) " links were created between nodes.") 
  SETUP-MONITOR 1  (word (count nodes with [not any? my-links]) " nodes are disconnected.")
end

; Create a node on the given patch
to make-node-here
  sprout-nodes 1 [
    set shape "dot"
    set size 2
    set color white
    set anchor? false
    set hidden? true 
  ]
end

; Create an anchor node on the given patch
to make-anchor-here
  sprout-nodes 1 [
    set shape "dot"
    set size 5
    set color red
    set anchor? true
    set hidden? true 
  ]
end

; Any node that is not connected to basic node graph (that includes the open water nodes) should be removed.
to remove-disconnected-nodes
  SETUP-MONITOR 0  "Removing disconnected nodes."
  ask max-one-of nodes with [anchor?] [count my-links][ ; assume anchor of highest degree is connected
     set color yellow
     mark-connected-yellow 
  ]
  ask nodes with [color != yellow][die]
  SETUP-MONITOR 1 (word (count nodes) " nodes remain with " (count links) " edges.")
  ask nodes [ifelse anchor? [set color red][set color white]]
end

to mark-connected-yellow
  ask link-neighbors [
    if color != yellow [
      set color yellow 
      mark-connected-yellow
    ]
  ]
end

; Deadends are portions of graphs that go up fjords. These do not help, as the path from all nodes in that fjord will follow the same
; channel out the fjor. So remove these nodes to make the graph more efficient and use less memory.
to remove-deadends
  SETUP-MONITOR 0 "Removing nodes of degree 1"
  while [any? nodes with [count my-links = 1]][
    ask nodes with [count my-links = 1][die]
  ]
  SETUP-MONITOR 1  (word (count nodes) " nodes remain with " (count links) " edges.")
end

; Each water patch is set with its nearest node in the graph, and with a pointer to the next patch on a path to that node. 
; To find that node, it can follow a sequence of to-nodes.
; An interleaved SSSP-style algorithm is employed to compute this, running simultaneoulsy from all nodes.
; Note that the distance metric is not L2. The path follows horizontal, verticle, and diagonal steps to neighboring patches.
to find-nearest-nodes
  ask water [set nearest-node nobody set to-node nobody]        ; Initialization
  let queue (list )                                             ; Queue of unvisited water patches to be processed.
  ask nodes [                                                   ; For each node, queue up the patch it is on. That patch is closest to that node.                                    
    ask patch-here [
      set nearest-node myself
      set to-node self
      set queue lput self queue
    ]
  ]
  
  ; Visit each patch in the queue, and then update its neighbors.
  while [not empty? queue][
     let front first queue                                      ; Remove patch from queue
     set queue but-first queue
     ask front [                                                
       let ffn nearest-node                                     ; Remember its nearest node
       let path self                                                      
       ask neighbors [                                          ; See if its neighbors have a new shortest path through this patch to a node
          if nearest-node = nobody [
             set nearest-node ffn
             set to-node path
             set queue lput self queue            
          ]
       ]
     ]
  ]
  SETUP-MONITOR 0 "Done finding nearest node for all patches."
end

; Use the Dijstra SSSP algorithm to compute the shortest path from each node to each anchor.
; The shortest path info for each node will be stored in the distlist and nextlist array, where item i in the array is for anchor i.
to all-anchors-SSSP
  let inf 1000000000000    ;  a large number greater than any path on the graph.
  SETUP-MONITOR 0  (word "Running the SSSP graph algorithm for " count nodes with [anchor?] " anchor nodes.")

  ; Initialize the lists and node information for nearest anchors
  ask nodes [
    set nextlist (list )
    set distlist (list )
    set nearest-anchor nobody
    set nearest-anchor-dist inf
  ]
   
  ; Number the anchors sequentially.  
  ; nextlist will store, at position i, the next pointer for the SSSP for anchor with id i. 
  ; dist list will store, at position i, the shorest known graph distance to node i.
  let anchor-count 0
  ask nodes with [anchor?] [
    set id anchor-count 
    set anchor-count anchor-count + 1
    set nearest-anchor self
    set nearest-anchor-dist 0
  ]
  
  ; Repeatedly call the SSSP algorithm for each anchor from 0 through the maximum anchor number.
  let i 0
  while [i < anchor-count][
    SSSP i
    set i (i + 1)
  ]
  
  show "SSSP done for all nodes"
end

; Compute the shortest path from every node to the anchor node with the given id.
to SSSP [anchor-number]
  SETUP-MONITOR 1  (word "SSSP on anchor " anchor-number ".")
  let inf 1000000000000    ;  a large number greater than any path on the graph.
  
  ; Add intial info about this anchor to the list for each node.
  ask nodes [ 
    set distlist (lput inf distlist)
    set nextlist (lput self nextlist)
  ]
  
  ; Find the node that is the given anchor, and start the SSSP algorithm.
  let origin one-of nodes with [anchor? and id = anchor-number]        ; There is only one choice.
  ask origin [                                                         ; Initialize the shortest path from this anchor to itself
    set distlist (replace-item anchor-number distlist 0)
    set nextlist (replace-item anchor-number nextlist self)
  ]
  
  ; Run the dijstra SSSP algorithm on all the other nodes to find the shortest path to the origin node which is an anchor node.
  let queue nodes
  while [any? queue][
     let front min-one-of queue [item anchor-number distlist]
     ask front [
       ask link-neighbors [
         ; if distance to this link-neighbor is shorter through myself, update the structure
         if (distance myself) + (item anchor-number [distlist] of myself) < (item anchor-number distlist) [
            set distlist replace-item anchor-number distlist ((distance myself) + (item anchor-number [distlist] of myself))
            set nextlist replace-item anchor-number nextlist myself
            if item anchor-number distlist < nearest-anchor-dist [
               set nearest-anchor origin
               set nearest-anchor-dist item anchor-number distlist
            ]
         ]
       ]
     ]
     set queue queue with [self != front]
  ]
end

;  =============== REPORTERS FOR FINDING AN EFFICIENT PATH THROUGH WATER FROM ONE PATCH TO ANOTHER ======================
; A path is simply a list of patches.  The patch is navigable. All patches are water, and it does not cross land to get from 
; one coastal patch to another.

; Creates a path (list of patches) from patch p1 to p2. 
; It is NOT necessarily the minimum length path.
; The path goes from patch p1 onto the node graph, follows a shortest path on the graph to an anchor, and then reverses that process to get to patch p2.
; The starting patch and the final patch are included. 
to-report path-from-patch-to-patch [p1 p2]
  ; For the starting and ending patches, find the nearest node on the travel graph
  let n1 [nearest-node] of p1
  let n2 [nearest-node] of p2

  ; The path will have three parts: p1 -> n1  followed by n1 -> n2 followed by n2 -> p2. 
  ; Start with the path p1 -> n1
  let path path-to-nearest-node p1
  
  ; Compute the path from n1 to n2, and append.
  let temp-path path-from-node-to-node n1 n2
  set path merge-path path temp-path
  
  ; Compute the path from n2 to p2 and append it
  set temp-path path-from-nearest-node p2
  set path merge-path path temp-path
  
  report path
end

; Finds and reports the path of patches from patch p to its nearest node on the travel graph. 
; The starting patch and the final patch are included. 
to-report path-to-nearest-node [p]
   let result (list p)                 ; initialize the path to contain just the starting patch
   let n [nearest-node] of p           ; n is the nearest node to patch p
   while [p != [patch-here] of n][     ; the path is done when it reaches the patch the node n is on
     set p [to-node] of p              ; If the path is not done, get the next node on the path from p to n...
     set result lput p result          ; ... and add it to the end of the list.
   ]
   report result
end


; This procedure should report the reverse of the above procedure: path-to-nearest-node.
; That is, it reports a path to patch p from its nearest node.
; It should be more efficient to compute it directly than to compute the path to the node and then reverse it.
; It is computer in the same way as path-to-nearest-node except new patches are added to the front, not the end, of the list.
to-report path-from-nearest-node [p]
   let result (list p)                  ; Add each patch on the path to a new list, in reverse order.
   let n [nearest-node] of p
   while [p != [patch-here] of n][
     set p [to-node] of p
     set result fput p result
   ]                                
   report result
end

; Reports the path of patches from node n1 to node n2 following the shortest path info on the graph.
; This is done by following the path from n1 to the nearest anchor to n2, and then appending the reverse of the
; path from n2 to its nearest anchor.  
; Note that this is not necessarily the shortest path from n1 to n2. For example, path may reach the anchor and then backtrack.
to-report path-from-node-to-node [n1 n2]
  let anc [nearest-anchor] of n2                  ; the nearest anchor of n2
  let path1 path-from-node-to-anchor n1 anc       ; Get the path from n1 to anc
  let path2 path-from-node-to-anchor n2 anc       ; The reverse of the path from anc to n2
  
  ; check if path2 backtracks on the end of path1, and if so remove that extra part
  while [length path1 > 1 and length path2 > 1 and second-to-last path1 = second-to-last path2][
    set path1 butlast path1
    set path2 butlast path2
  ]
  
  report merge-path path1 (reverse path2)         ; The final result
end

; Reports the path of patches from node n1 to anchor node anc following the shortest path info on the graph.
; The patches of both n and anc are  included in the path.
to-report path-from-node-to-anchor [n anc]
  let index [id] of anc                             ; The index of anc determines where in the nextlist of nodes the shortest path to anc is stored.
  let path (list [patch-here] of n)                   ; create an empty path of patches
  while [n != anc] [                                ; for each edge (n,nn) in the shorest path on the graph, find the corresponding path of patches and append to path.
    let nn (item index ([nextlist] of n))
    let partial (find-line ([xcor] of n) ([ycor] of n) ([xcor] of nn) ([ycor] of nn))
    set path (merge-path path partial)
    set n nn
  ]
  report path
end

; Append a list of patches p2 to the end of the list p1.  
; The first node of p2 should be the same as the last node of p1.  This duplicate is removed.
; Any other backtracking part of the path is removed.
to-report merge-path [p1 p2]
   ifelse last p1 != first p2 [ 
     DEBUG-MONITOR 1 "ERROR: merging paths that do not overlap" 
   ][
     set p2 butfirst p2
   ]
   
   ; check if the start of path 2 backtracks along the end of path 1, and if so remove overlap
   while [length p1 > 1 and length p2 > 0 and second-to-last p1 = first p2][
      set p1 butlast p1
      set p2 butfirst p2
   ]
   
   report sentence p1 p2
end

; report the second to last item in patch list pl. Assume the last has length > 1
to-report second-to-last [pl]
   let n length pl
   if n < 2 [ DEBUG-MONITOR 1 "ERROR: Looking at the second to last element of a list of length < 2"  report nobody]
   report item (n - 2) pl
end

to color-voronoi-regions
  ask patches [set pcolor voronoi-region-color]
end

to color-hunting-regions
  ask patches [set pcolor hunting-region-color]
end

to-report hunting-region
  report [id] of ([nearest-anchor] of nearest-node)
end

to-report voronoi-region-color
  if water? [report region * 10 + 7.5]
  report region * 10 + 5
end

to-report hunting-region-color
  if water? [report hunting-region * 10 + 7.5]
  report green - 2
end

to identify-shoreline
  set shore patches with [(not water?) and (count (neighbors with [coastal?])) > 0]
  ask shore [set pcolor black]
  ask coast [set pcolor white]
end

to-report shore-pair-normal-angle [shore-pair]
  let coastal-patch item 0 shore-pair
  let shore-patch item 1 shore-pair
  let delx (([pxcor] of coastal-patch) - ([pxcor] of shore-patch))
  let dely (([pycor] of coastal-patch) - ([pycor] of shore-patch))
  report atan delx dely ; remember that sin is +x and cos is +y. i.e. theta=0 points along +y, and +theta is CW!
end

; For dir: CW is +1
;          CCW is -1
; Remember that the cw and ccw naming here will
; be reversed on a -1
to-report inc-shore [shore-pair dir]
  let coastal-patch item 0 shore-pair
  let shore-patch item 1 shore-pair
  DEBUG-MONITOR 3 (word coastal-patch shore-patch)
  let cx [pxcor] of coastal-patch
  let cy [pycor] of coastal-patch
  let sx [pxcor] of shore-patch
  let sy [pycor] of shore-patch
  let sr [region] of shore-patch

  let theta shore-pair-normal-angle shore-pair
  let theta-cw ((theta + (dir * 45)) mod 360)
  
  let next-patch patch (sx + (sin theta-cw)) (sy + (cos theta-cw))
  ifelse next-patch = nobody [
    ; We've wandered off the edge of the map
    set coastal-patch nobody
    set shore-patch nobody
  ] [ 
    let nx1 [pxcor] of next-patch
    let ny1 [pycor] of next-patch
    ifelse ([water?] of next-patch) [
      let ntheta-ccw ((theta-cw + (dir * 135)) mod 360) ; Reverse the vector between shore and next-patch and swing 45 ccw
      set coastal-patch next-patch
      ; Should end up here for flat or convex coastline
      ; See if we can swing the land pointer up to match!
      let next-shore-patch patch (nx1 + (sin ntheta-ccw)) (ny1 + (cos ntheta-ccw))
      set shore-patch ifelse-value ((next-shore-patch = nobody) or ([water?] of next-shore-patch) or (not (sr = ([region] of next-shore-patch)))) [shore-patch][next-shore-patch]
    ] [
      let ntheta-ccw ((theta + (dir * 135)) mod 360) ; Reverse the vector between shore and coastal, and swing 45 ccw
      let test-patch patch (cx + (sin ntheta-ccw)) (cy + (cos ntheta-ccw))
      ; We're in a corner, make sure we don't skip in anybody
      ifelse (sr = ([region] of next-patch)) [
        set shore-patch ifelse-value ((test-patch = nobody) or ([water?] of test-patch) or (test-patch = next-patch) or (not (sr = ([region] of test-patch)))) [next-patch][test-patch]
      ] [
        set coastal-patch test-patch
      ]
      if ([water?] of shore-patch)[
        DEBUG-MONITOR 1 "Eek, shore landed on water, something is wrong"
      ]
    ]
  ]
  report (list coastal-patch shore-patch)
  
end

to-report find-a-shore [coastal-patch]

  let shore-patch nobody
  ifelse (not ([coastal?] of coastal-patch)) [
    ifelse (not ([water?] of coastal-patch))[
      DEBUG-MONITOR 1 (word coastal-patch " is not in the water, trying to find some coastline")
      set shore-patch coastal-patch
      set coastal-patch min-one-of (([neighbors] of shore-patch) with [coastal?]) [distance shore-patch]
    ][
      DEBUG-MONITOR 1 (word coastal-patch " is not a coastal patch, finding coast too")
      set shore-patch ([nearest-land] of coastal-patch)
      set coastal-patch min-one-of (([neighbors] of shore-patch) with [coastal?]) [distance shore-patch]
    ]
  ][
    set shore-patch [nearest-land] of coastal-patch
  ]
  report (list coastal-patch shore-patch )
end

to color-a-shore [coastal-patch]
  let cs-pair find-a-shore coastal-patch
  let i 0
  while [(i < 120) and not (cs-pair = [nobody nobody])] [
    ask (item 0 cs-pair) [set pcolor red - 2]
    ask (item 1 cs-pair) [set pcolor orange - 2]
    set cs-pair inc-shore cs-pair 1
    set i i + 1
  ]
  set i 0
  set cs-pair find-a-shore coastal-patch
  while [(i < 120) and not (cs-pair = [nobody nobody])] [
    ask (item 0 cs-pair) [set pcolor red + 2]
    ask (item 1 cs-pair) [set pcolor orange + 2]
    set cs-pair inc-shore cs-pair -1
    set i i + 1
  ]
end
